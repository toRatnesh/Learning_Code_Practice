/*****

References

    Effective Modern C++ | Scott Meyers
	https://en.cppreference.com/w/cpp/language/reference
	https://en.cppreference.com/w/cpp/utility/forward

Item 30: Familiarize yourself with perfect forwarding failure cases

	Perfect forwarding means we don’t just forward objects, we also forward their salient characteristics: 
	their types, whether they’re lvalues or rvalues, and whether they’re const or volatile.


	Let’s assume we have some function f, and we’d like to write a function (in truth, a function template) that forwards to it.
	
	template<typename... Ts>
	void fwd(Ts&&... params) {				// accept any arguments
		f(std::forward<Ts>(params)...);		// forward them to f
	}

	Given our target function f and our forwarding function fwd, 
	perfect forwarding fails if calling f with a particular argument does one thing, 
	but calling fwd with the same argument does something different:
	
	f( expression );	// if this does one thing
	fwd( expression );	// but this does something else, fwd fails to perfectly forward expression to f


	Perfect forwarding fails when either of the following occurs:
	•	Compilers are unable to deduce a type for one or more of fwd’s parameters. In this case, the code fails to compile.
	•	Compilers deduce the “wrong” type for one or more of fwd’s parameters.
		fwd’s instantiation won’t compile with the types that were deduced
		call to f using fwd’s deduced types behaves differently from a direct call to f
		
		One source of such divergent behavior would be if f were an overloaded function name, and, 
		due to “incorrect” type deduction, different version of f is called


The kinds of arguments that can’t be perfect-forwarded
	1.	Braced initializers
	2.	0 or NULL as null pointers
	3.	Declaration-only integral static const data members
	4.	Overloaded function names and template names
	5.	Bitfields


1.	Braced initializers
	void f(const std::vector<int>& v);
	
	f({ 1, 2, 3 });		// fine, "{1, 2, 3}" implicitly converted to std::vector<int>
	
	fwd({ 1, 2, 3 });	// error! doesn't compile
	
	That’s because the use of a braced initializer is a perfect forwarding failure case.
	
	The problem is that passing a braced initializer to a function template parameter 
	that’s not declared to be a std::initializer_list is decreed to be, 
	as the Standard puts it, a “non-deduced context.” 
	
	Work around:
		initialize a variable with braced initializer and use it
		
		auto il = { 1, 2, 3 };	// il's type deduced to be std::initializer_list<int>
		fwd(il);				// fine, perfect-forwards il to f


2.	0 or NULL as null pointers
	
	neither 0 nor NULL can be perfect-forwarded as a null pointer
	in this case type deduction is an integral type
	
	Work around:
		pass nullptr instead of 0 or NULL
	
3.	Declaration-only integral static const data members

	As a general rule, there’s no need to define integral static const data members in classes; 
	declarations alone suffice. 
	That’s because compilers perform const propagation on such members’ values, 
	thus eliminating the need to set aside memory for them.

	class Widget {
		public:
		static const std::size_t MinVals = 28;	// MinVals' declaration
		…
	};
	…		// no defn. for MinVals

	std::vector<int> widgetData;
	widgetData.reserve(Widget::MinVals);		// use of MinVals

	The fact that no storage has been set aside for MinVals’ value is unproblematic.
	If MinVals’ address were to be taken, then MinVals would require storage, and the code above, 
	though it would compile, would fail at link-time until a definition for MinVals was provided.
	
	void f(std::size_t val);
	
	f(Widget::MinVals);			// fine, treated as "f(28)"
	
	fwd(Widget::MinVals);		// error! shouldn't link
	
	fwd’s parameter is a universal reference, and references, 
	in the code generated by compilers, are usually treated like pointers
	
	According to the Standard, passing MinVals by reference requires that it be defined. 
	But not all implementations enforce this requirement. So, depending on your compilers and linkers, 
	you may find that you can perfect-forward integral static const data members that haven’t been defined.
	
	Work around:
		To make it portable, simply provide a definition for the integral static const data member
		const std::size_t Widget::MinVals;		// in .cpp file
	
	
4.	Overloaded function names and template names
	Consider following code
	
	void f(int (*pf)(int));		// pf = "processing function"
	void f(int pf(int));		// declares same f as above
	
	int processVal(int value);
	int processVal(int value, int priority);
	
	f(processVal);				// fine
	fwd(processVal);			// error! which processVal?
	processVal alone has no type. Without a type, there can be no type deduction, 
	and without type deduction, we’re left with another perfect forwarding failure case

	template<typename T>
	T workOnVal(T param)		// template for processing values
	{ … }
	
	fwd(workOnVal);				// error! which workOnVal instantiation?
	
	
	Work around:
		to get a perfect-forwarding function like fwd to accept an overloaded function name or a template name 
		is to manually specify the overload or instantiation you want to have forwarded
		
		using ProcessFuncType = int (*)(int);
		ProcessFuncType processValPtr = processVal;
		
		fwd(processValPtr);
		fwd(static_cast<ProcessFuncType>(workOnVal));
	
	
5.	Bitfields

	struct IPv4Header {
		std::uint32_t version:4,
		IHL:4,
		DSCP:6,
		ECN:2,
		totalLength:16;
		…
	};	


	void f(std::size_t sz);	// function to call
	IPv4Header h;
	…
	f(h.totalLength);		// fine

	fwd(h.totalLength);		// error!
	
	The problem is that fwd’s parameter is a reference, and h.totalLength is a nonconst bitfield
	
	According to C++ Standard: “A non-const reference shall not be bound to a bit-field.”
	Reason for the prohibition: 
		Bitfields may consist of arbitrary parts of machine words (e.g., bits 3-5 of a 32-bit int), 
		but there’s no way to directly address such things.
	
	Work around:
		function that accepts a bitfield as an argument will receive a copy of the bitfield’s value
		After all, no function can bind a reference to a bitfield, nor can any function accept pointers to bitfields, 
		because pointers to bitfields don’t exist
		
		only kinds of parameters to which a bitfield can be passed are by-value parameters and, interestingly, references-to-const
		
		The key to passing a bitfield into a perfect-forwarding function, then, is to take advantage of the fact 
		that the forwarded-to function will always receive a copy of the bitfield’s value. 
		You can thus make a copy yourself and call the forwarding function with the copy
		
		auto length = static_cast<std::uint16_t>(h.totalLength);
		fwd(length); // forward the copy
	
		
Summary
	•	Perfect forwarding fails when template type deduction fails or when it deduces the wrong type.
	•	The kinds of arguments that lead to perfect forwarding failure are 
			braced initializers,
			null pointers expressed as 0 or NULL, d
			eclaration-only integral const static data members, 
			template and overloaded function names, and 
			bitfields.


**********/

#include <iostream>
#include <vector>
#include <string>
#include <cstdint>

struct DATA_SIZE {
    static const size_t ARR_SIZE{64};
};
const size_t DATA_SIZE::ARR_SIZE;

void fun(const std::vector<int> & ) {
    std::puts("Using vector");
}

void fun(const int * ) {
    std::puts("Using int pointer");
}

void fun(const size_t ) {
    std::puts("Using size_t");
}

void fun(int (*)(int)) {
    std::puts("Using funciton pointer");
}

void display_seprately(int (*)(int)) {
    std::puts("Using funciton pointer");
}

int display(int ) { std::puts("display(int )"); return 0; }
int display(int, std::string ) { std::puts("display(int, std::string )"); return 0; }

template<typename T>
void forward_it(T&&  val) {
    fun(std::forward<T>(val));
}

int main() {
    {   std::puts("=== 1. Braced initializers ===");
        fun({1, 2, 3, 4, 5});
        // CE error: no matching function for call to 'forward_it(<brace-enclosed initializer list>)'
        // forward_it({1, 2, 3, 4, 5});

        auto intlist = {1, 2, 3, 4, 5};
        forward_it(intlist);
    }
    {   std::puts("\n=== 2. 0 or NULL as null pointers ===");

        // fun(0);       // this will call pointer version
        //fun(NULL);    // this will call pointer version
        display_seprately(0);
        display_seprately(NULL);

        // CE error: invalid conversion from 'int' to 'const int*'
        // forward_it(0);

        // CE error: invalid conversion from 'long int' to 'const int*'
        // forward_it(NULL);

        // forward_it(nullptr);    // this will call pointer version
        display_seprately(nullptr);
    }

    {   std::puts("\n=== 3. Declaration-only integral static const data members ===");
        fun(DATA_SIZE::ARR_SIZE);
        forward_it(DATA_SIZE::ARR_SIZE);    // LE: undefined reference to `DATA_SIZE::ARR_SIZE'
    }

    {   std::puts("\n=== 4. Overloaded function names and template names ===");
        fun(display);

        // error: no matching function for call to 'forward_it(<unresolved overloaded function type>)'
        // forward_it(display);

        using display_int_t = int(*)(int );
        display_int_t l_display_fun = display;
        forward_it(l_display_fun);
    }

    {   std::puts("\n=== 5. Bitfields ===");
        struct IPv4Header {
            std::uint32_t version:4,
            IHL:4,
            DSCP:6,
            ECN:2,
            totalLength:16;
        }; 

        IPv4Header l_ip4_header;    l_ip4_header.totalLength = 16;
        fun(l_ip4_header.totalLength);
        // error: cannot bind bit-field 'l_ip4_header.main()::IPv4Header::totalLength' to 'unsigned int&'
        // forward_it(l_ip4_header.totalLength);

        const std::size_t l_total_len = static_cast<std::size_t>(l_ip4_header.totalLength);
        forward_it(l_total_len);
    }

    return 0;
}

/*****
    END OF FILE
**********/


