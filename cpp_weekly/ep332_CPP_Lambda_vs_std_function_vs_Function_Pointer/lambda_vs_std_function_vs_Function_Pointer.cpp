/********
  This example demonstrates about differences between C++ Lambda, std::function and function pointer

Lmabda: A way of defining a callable object in C++. It's generated by the compiler for you.
std::function : a type erased wrapper around a callable that gives you this generic interface that you can pass around.
It's more flexible than function pointer.

For more info visit:
https://www.youtube.com/watch?v=aC-aAiS5Wuc&list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1&index=333

 *********/

#include <iostream>
#include <cassert>
#include <functional>

struct S {
	int m = 5;

	public:
	int memberFun(int arg) {
		return arg+m;
	}

	static int staticMemberFun(int arg) {
		return arg*2;
	}
};

int main() {
	auto alambda = [](const int x, const int y) { return x+y; };
	static_assert(5 == alambda(2,3));
	std::function<int (int, int)> func{alambda};
	//static_assert(5 == func(2,3));
	assert(5 == func(2,3));
	int (*fp)(int, int) = nullptr;
	fp = alambda;
	//static_assert(5 == fp(2,3));
	assert(5 == fp(2,3));

	const int multiply_by_this = 7;
	auto alambda2 = [multiply_by_this](const int val) { return val * multiply_by_this;};
	static_assert(56 == alambda2(8));
	std::function<int (int)> func2{alambda2};
	assert(56 == func2(8));
	int (*fp2)(int) = nullptr;
	//fp2 = alambda2;   // lambda with caputre is not convertible to function pointer
	// CE error: cannot convert 'main()::<lambda(int)>' to 'int (*)(int)' in assignment

	// For static member functions (it's like free fucntions)
	func2 = S::staticMemberFun;
	assert(8 == func2(4));
	fp2 = S::staticMemberFun;
	assert(10 == fp2(5));

	// For member functions
	std::function<int (S&, int)> funcm = &S::memberFun;
	int (S::*fpm)(int) = nullptr;
	fpm = &S::memberFun;
	S sobj;
	assert(10 == (sobj.*fpm)(5));
	assert(8 == funcm(sobj, 3));

	return 0;
}

/*****
  END OF FILE
 *****/
